#!/usr/bin/env python3
"""
Unified Kafka Consumer System

This module provides a unified, configurable Kafka consumer system that consolidates
all the functionality from the individual consumer files:
- ML prediction processing
- Database storage
- Consumer group support
- Producer capabilities
- Flexible message handling

Author: Generated by GitHub Copilot
"""

import json
import sqlite3
import numpy as np
import sys
import argparse
from abc import ABC, abstractmethod
from datetime import datetime
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from kafka import KafkaConsumer, KafkaProducer

from model_loader import load_house_price_model


@dataclass
class ConsumerConfig:
    """Configuration for the unified consumer"""
    # Kafka settings
    bootstrap_servers: List[str] = field(default_factory=lambda: ['nowledgeable.com:9092'])
    input_topic: str = 'house_data'
    output_topic: str = 'prediction_duport'
    
    # Consumer settings
    consumer_group: Optional[str] = None
    consumer_id: Optional[str] = None
    auto_offset_reset: str = 'latest'
    
    # Database settings
    enable_database: bool = False
    db_path: str = 'predictions.db'
    
    # Producer settings
    enable_producer: bool = False
    
    # Processing settings
    enable_ml_prediction: bool = True
    enable_display: bool = True
    
    # Model settings
    model_type: str = 'LinearRegression'


class MessageHandler(ABC):
    """Abstract base class for message handlers"""
    
    @abstractmethod
    def setup(self) -> None:
        """Setup the handler"""
        pass
    
    @abstractmethod
    def handle(self, message_data: Dict[str, Any], consumer_id: Optional[str] = None) -> Optional[Dict[str, Any]]:
        """Handle a message and optionally return processed data"""
        pass
    
    @abstractmethod
    def cleanup(self) -> None:
        """Cleanup resources"""
        pass


class MLPredictionHandler(MessageHandler):
    """Handler for ML predictions"""
    
    def __init__(self, config: ConsumerConfig):
        self.config = config
        self.model = None
    
    def setup(self) -> None:
        """Load the ML model"""
        try:
            self.model = load_house_price_model()
            print("ML model loaded successfully")
        except Exception as e:
            print(f"Failed to load model: {e}")
            raise
    
    def handle(self, message_data: Dict[str, Any], consumer_id: Optional[str] = None) -> Optional[Dict[str, Any]]:
        """Make house price prediction"""
        try:
            # Extract features in the correct order
            features = np.array([[
                message_data['square_feet'],
                message_data['bedrooms'],
                message_data['bathrooms'],
                message_data['age']
            ]])
            
            # Make prediction
            prediction = self.model.predict(features)[0]
            
            # Create prediction result
            result = {
                "input_data": message_data,
                "predicted_price": round(prediction, 2),
                "model_type": self.config.model_type,
                "timestamp": datetime.now().isoformat()
            }
            
            if consumer_id:
                result["processed_by"] = consumer_id
            if self.config.consumer_group:
                result["consumer_group"] = self.config.consumer_group
                
            prefix = f"[{consumer_id}] " if consumer_id else ""
            print(f"{prefix}Predicted Price: ${prediction:,.2f}")
            
            return result
            
        except KeyError as e:
            print(f"Missing required feature: {e}")
            return None
        except Exception as e:
            print(f"Error making prediction: {e}")
            return None
    
    def cleanup(self) -> None:
        """No cleanup needed for ML handler"""
        pass


class DatabaseHandler(MessageHandler):
    """Handler for database storage"""
    
    def __init__(self, config: ConsumerConfig):
        self.config = config
        self.conn = None
    
    def setup(self) -> None:
        """Setup SQLite database"""
        try:
            self.conn = sqlite3.connect(self.config.db_path)
            cursor = self.conn.cursor()
            
            # Create predictions table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS predictions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                    square_feet REAL,
                    bedrooms INTEGER,
                    bathrooms INTEGER,
                    age INTEGER,
                    predicted_price REAL,
                    model_type TEXT,
                    processed_by TEXT,
                    consumer_group TEXT
                )
            ''')
            
            self.conn.commit()
            print(f"Database setup completed: {self.config.db_path}")
            
        except Exception as e:
            print(f"Error setting up database: {e}")
            raise
    
    def handle(self, message_data: Dict[str, Any], consumer_id: Optional[str] = None) -> Optional[Dict[str, Any]]:
        """Store prediction in database"""
        try:
            cursor = self.conn.cursor()
            
            input_data = message_data.get('input_data', message_data)
            
            cursor.execute('''
                INSERT INTO predictions 
                (square_feet, bedrooms, bathrooms, age, predicted_price, model_type, processed_by, consumer_group)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                input_data['square_feet'],
                input_data['bedrooms'],
                input_data['bathrooms'],
                input_data['age'],
                message_data.get('predicted_price'),
                message_data.get('model_type', 'Unknown'),
                message_data.get('processed_by', consumer_id),
                message_data.get('consumer_group')
            ))
            
            self.conn.commit()
            
            prefix = f"[{consumer_id}] " if consumer_id else ""
            print(f"{prefix}Prediction stored in database (ID: {cursor.lastrowid})")
            
            return message_data
            
        except Exception as e:
            print(f"Error storing prediction: {e}")
            return message_data
    
    def get_database_stats(self) -> Optional[Dict[str, Any]]:
        """Get database statistics"""
        try:
            cursor = self.conn.cursor()
            
            # Get total count
            cursor.execute('SELECT COUNT(*) FROM predictions')
            total_count = cursor.fetchone()[0]
            
            # Get average price
            cursor.execute('SELECT AVG(predicted_price) FROM predictions')
            avg_price = cursor.fetchone()[0]
            
            # Get latest prediction
            cursor.execute('''
                SELECT timestamp, predicted_price 
                FROM predictions 
                ORDER BY timestamp DESC 
                LIMIT 1
            ''')
            latest = cursor.fetchone()
            
            return {
                'total_predictions': total_count,
                'average_price': avg_price if avg_price else 0,
                'latest_prediction': latest
            }
            
        except Exception as e:
            print(f"Error getting database stats: {e}")
            return None
    
    def cleanup(self) -> None:
        """Clean up database connection"""
        if self.conn:
            self.conn.close()
            print("Database connection closed")


class DisplayHandler(MessageHandler):
    """Handler for displaying messages"""
    
    def __init__(self, config: ConsumerConfig):
        self.config = config
    
    def setup(self) -> None:
        """No setup needed for display handler"""
        pass
    
    def handle(self, message_data: Dict[str, Any], consumer_id: Optional[str] = None) -> Optional[Dict[str, Any]]:
        """Display message data"""
        prefix = f"[{consumer_id}] " if consumer_id else ""
        
        if 'predicted_price' in message_data:
            # This is a prediction message
            print(f"{prefix}Received Prediction:")
            print(f"{prefix}  Input Data: {message_data.get('input_data', 'N/A')}")
            print(f"{prefix}  Predicted Price: ${message_data['predicted_price']:,.2f}")
            print(f"{prefix}  Model Type: {message_data.get('model_type', 'Unknown')}")
            if message_data.get('processed_by'):
                print(f"{prefix}  Processed By: {message_data['processed_by']}")
        else:
            # This is raw house data
            print(f"{prefix}Received house data: {message_data}")
        
        return message_data
    
    def cleanup(self) -> None:
        """No cleanup needed for display handler"""
        pass


class UnifiedKafkaConsumer:
    """Unified Kafka consumer with configurable handlers"""
    
    def __init__(self, config: ConsumerConfig):
        self.config = config
        self.consumer = None
        self.producer = None
        self.handlers: List[MessageHandler] = []
        
        # Setup handlers based on configuration
        self._setup_handlers()
    
    def _setup_handlers(self) -> None:
        """Setup message handlers based on configuration"""
        if self.config.enable_ml_prediction:
            self.handlers.append(MLPredictionHandler(self.config))
        
        if self.config.enable_display:
            self.handlers.append(DisplayHandler(self.config))
        
        if self.config.enable_database:
            self.handlers.append(DatabaseHandler(self.config))
    
    def setup(self) -> None:
        """Setup consumer, producer, and handlers"""
        self._setup_consumer()
        
        if self.config.enable_producer:
            self._setup_producer()
        
        # Setup all handlers
        for handler in self.handlers:
            handler.setup()
    
    def _setup_consumer(self) -> None:
        """Setup Kafka consumer"""
        try:
            consumer_kwargs = {
                'bootstrap_servers': self.config.bootstrap_servers,
                'auto_offset_reset': self.config.auto_offset_reset,
                'value_deserializer': lambda x: json.loads(x.decode('utf-8'))
            }
            
            # Add consumer group if specified
            if self.config.consumer_group:
                consumer_kwargs['group_id'] = self.config.consumer_group
            
            # Add client ID if specified
            if self.config.consumer_id:
                consumer_kwargs['client_id'] = self.config.consumer_id
            
            self.consumer = KafkaConsumer(self.config.input_topic, **consumer_kwargs)
            
            prefix = f"[{self.config.consumer_id}] " if self.config.consumer_id else ""
            print(f"{prefix}Consumer connected to topic '{self.config.input_topic}'")
            if self.config.consumer_group:
                print(f"{prefix}Consumer group: {self.config.consumer_group}")
            
        except Exception as e:
            print(f"Failed to setup consumer: {e}")
            raise
    
    def _setup_producer(self) -> None:
        """Setup Kafka producer"""
        try:
            producer_kwargs = {
                'bootstrap_servers': self.config.bootstrap_servers,
                'value_serializer': lambda x: json.dumps(x).encode('utf-8')
            }
            
            # Add client ID if specified
            if self.config.consumer_id:
                producer_kwargs['client_id'] = f"{self.config.consumer_id}_producer"
            
            self.producer = KafkaProducer(**producer_kwargs)
            
            prefix = f"[{self.config.consumer_id}] " if self.config.consumer_id else ""
            print(f"{prefix}Producer connected to topic '{self.config.output_topic}'")
            
        except Exception as e:
            print(f"Failed to setup producer: {e}")
            raise
    
    def start_consuming(self) -> None:
        """Start consuming messages"""
        prefix = f"[{self.config.consumer_id}] " if self.config.consumer_id else ""
        print(f"{prefix}Starting unified Kafka consumer...")
        print(f"{prefix}Consuming from: {self.config.input_topic}")
        if self.config.enable_producer:
            print(f"{prefix}Producing to: {self.config.output_topic}")
        print(f"{prefix}Handlers: {[type(h).__name__ for h in self.handlers]}")
        print(f"{prefix}Waiting for messages...")
        print("-" * 80)
        
        try:
            for message in self.consumer:
                message_data = message.value
                processed_data = message_data
                
                # Process message through all handlers
                for handler in self.handlers:
                    result = handler.handle(processed_data, self.config.consumer_id)
                    if result is not None:
                        processed_data = result
                
                # Send to output topic if producer is enabled and we have processed data
                if self.config.enable_producer and self.producer and processed_data != message_data:
                    try:
                        self.producer.send(self.config.output_topic, processed_data)
                        send_prefix = f"[{self.config.consumer_id}] " if self.config.consumer_id else ""
                        print(f"{send_prefix}Message sent to '{self.config.output_topic}' topic")
                    except Exception as e:
                        print(f"Error sending message: {e}")
                
                # Show database stats if database handler is present
                db_handler = next((h for h in self.handlers if isinstance(h, DatabaseHandler)), None)
                if db_handler:
                    stats = db_handler.get_database_stats()
                    if stats:
                        stats_prefix = f"[{self.config.consumer_id}] " if self.config.consumer_id else ""
                        print(f"{stats_prefix}Database Stats: {stats['total_predictions']} predictions, "
                              f"Avg: ${stats['average_price']:,.2f}")
                
                print("-" * 80)
                
        except KeyboardInterrupt:
            interrupt_prefix = f"[{self.config.consumer_id}] " if self.config.consumer_id else ""
            print(f"\n{interrupt_prefix}Stopping consumer...")
        except Exception as e:
            error_prefix = f"[{self.config.consumer_id}] " if self.config.consumer_id else ""
            print(f"{error_prefix}Error in consumer loop: {e}")
        finally:
            self.cleanup()
    
    def cleanup(self) -> None:
        """Clean up all resources"""
        # Cleanup handlers
        for handler in self.handlers:
            handler.cleanup()
        
        # Cleanup Kafka connections
        if self.consumer:
            self.consumer.close()
            close_prefix = f"[{self.config.consumer_id}] " if self.config.consumer_id else ""
            print(f"{close_prefix}Consumer closed")
        
        if self.producer:
            self.producer.close()
            producer_prefix = f"[{self.config.consumer_id}] " if self.config.consumer_id else ""
            print(f"{producer_prefix}Producer closed")


def create_config_from_args() -> ConsumerConfig:
    """Create configuration from command line arguments"""
    parser = argparse.ArgumentParser(description='Unified Kafka Consumer')
    
    # Kafka settings
    parser.add_argument('--bootstrap-servers', nargs='+', 
                       default=['nowledgeable.com:9092'],
                       help='Kafka bootstrap servers')
    parser.add_argument('--input-topic', default='house_data',
                       help='Input topic to consume from')
    parser.add_argument('--output-topic', default='prediction_duport',
                       help='Output topic to produce to')
    
    # Consumer settings
    parser.add_argument('--consumer-group', 
                       help='Consumer group ID for load balancing')
    parser.add_argument('--consumer-id',
                       help='Unique consumer ID')
    parser.add_argument('--auto-offset-reset', default='latest',
                       choices=['earliest', 'latest'],
                       help='Auto offset reset policy')
    
    # Feature flags
    parser.add_argument('--enable-database', action='store_true',
                       help='Enable database storage')
    parser.add_argument('--db-path', default='predictions.db',
                       help='Database file path')
    parser.add_argument('--enable-producer', action='store_true',
                       help='Enable message producing')
    parser.add_argument('--disable-ml', action='store_true',
                       help='Disable ML predictions')
    parser.add_argument('--disable-display', action='store_true',
                       help='Disable message display')
    
    # Presets
    parser.add_argument('--preset', 
                       choices=['simple', 'ml-producer', 'ml-group', 'prediction-consumer', 'database-consumer'],
                       help='Use predefined configuration preset')
    
    args = parser.parse_args()
    
    # Create base config
    config = ConsumerConfig(
        bootstrap_servers=args.bootstrap_servers,
        input_topic=args.input_topic,
        output_topic=args.output_topic,
        consumer_group=args.consumer_group,
        consumer_id=args.consumer_id,
        auto_offset_reset=args.auto_offset_reset,
        enable_database=args.enable_database,
        db_path=args.db_path,
        enable_producer=args.enable_producer,
        enable_ml_prediction=not args.disable_ml,
        enable_display=not args.disable_display
    )
    
    # Apply presets
    if args.preset == 'simple':
        # Simple ML consumer (ml_consumer.py equivalent)
        config.enable_producer = False
        config.enable_database = False
        config.consumer_group = None
        
    elif args.preset == 'ml-producer':
        # ML consumer with producer (ml_consumer_producer.py equivalent)
        config.enable_producer = True
        config.enable_database = False
        config.consumer_group = None
        
    elif args.preset == 'ml-group':
        # ML consumer with group (ml_consumer_group.py equivalent)
        config.enable_producer = True
        config.enable_database = False
        config.consumer_group = args.consumer_group or 'ml_prediction_group'
        config.consumer_id = args.consumer_id or 'consumer_1'
        
    elif args.preset == 'prediction-consumer':
        # Prediction consumer (prediction_consumer.py equivalent)
        config.input_topic = 'prediction_duport'
        config.enable_ml_prediction = False
        config.enable_producer = False
        config.enable_database = False
        
    elif args.preset == 'database-consumer':
        # Database consumer (database_consumer.py equivalent)
        config.input_topic = 'prediction_duport'
        config.enable_ml_prediction = False
        config.enable_producer = False
        config.enable_database = True
    
    return config


def main():
    """Main function"""
    try:
        config = create_config_from_args()
        consumer = UnifiedKafkaConsumer(config)
        consumer.setup()
        consumer.start_consuming()
        
    except Exception as e:
        print(f"Failed to start unified consumer: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()